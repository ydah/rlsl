# frozen_string_literal: true

module RLSL
  module WGSL
    class Translator < BaseTranslator
      TYPE_MAP = {
        "vec2" => "vec2<f32>",
        "vec3" => "vec3<f32>",
        "vec4" => "vec4<f32>"
      }.freeze

      FUNC_REPLACEMENTS = BaseTranslator.common_func_replacements(
        target_vec2: "vec2<f32>",
        target_vec3: "vec3<f32>",
        target_vec4: "vec4<f32>"
      ).freeze

      protected

      def translate_code(c_code)
        result = super(c_code)
        return result if result.empty?

        result.gsub!(/\bstatic\s+/, "")
        result.gsub!(/\binline\s+/, "")
        result.gsub!(/\bfloat\b/, "f32")
        result
      end

      def generate_shader(helpers, fragment)
        <<~WGSL
          // WGSL Shader generated by RLSL

          struct Uniforms {
              #{generate_uniform_struct}
          };

          @group(0) @binding(0) var<uniform> u: Uniforms;
          @group(0) @binding(1) var output_texture: texture_storage_2d<rgba8unorm, write>;

          #{helpers}

          fn shader_fragment(frag_coord: vec2<f32>, resolution: vec2<f32>) -> vec3<f32> {
              let uv = frag_coord / resolution.y;
              #{fragment}
          }

          @compute @workgroup_size(8, 8)
          fn main(@builtin(global_invocation_id) gid: vec3<u32>) {
              let resolution = vec2<f32>(f32(textureDimensions(output_texture).x),
                                         f32(textureDimensions(output_texture).y));
              if (gid.x >= u32(resolution.x) || gid.y >= u32(resolution.y)) {
                  return;
              }

              let frag_coord = vec2<f32>(f32(gid.x), resolution.y - 1.0 - f32(gid.y));
              let color = shader_fragment(frag_coord, resolution);

              textureStore(output_texture, vec2<i32>(i32(gid.x), i32(gid.y)),
                           vec4<f32>(clamp(color, vec3<f32>(0.0), vec3<f32>(1.0)), 1.0));
          }
        WGSL
      end

      private

      def generate_uniform_struct
        fields = ["resolution: vec2<f32>,"]
        @uniforms.each do |name, type|
          wgsl_type = uniform_type_to_target(type)
          fields << "#{name}: #{wgsl_type},"
        end
        fields.join("\n    ")
      end

      def target_float_type
        "f32"
      end

      def target_vec2_type
        "vec2<f32>"
      end

      def target_vec3_type
        "vec3<f32>"
      end

      def target_vec4_type
        "vec4<f32>"
      end
    end
  end
end
